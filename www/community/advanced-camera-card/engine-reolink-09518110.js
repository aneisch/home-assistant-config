import{l as e,eb as t,ec as i,em as a,ea as n,eh as s,ed as r,el as o,ei as l,dW as c,d8 as u,en as h,ef as _,eg as d,ej as g,dg as p,di as m}from"./card-807d37f1.js";import{B as y,a as f,i as C,g as w}from"./within-dates-3186009f.js";import{C as k}from"./engine-86b0096c.js";import{g as b}from"./engine-generic-899f559e.js";import{p as D}from"./parse-efcd2707.js";import{e as M}from"./endOfDay-db974b48.js";import"./media-c9012082.js";class z extends n{}class E extends y{constructor(){super(...arguments),this._reolinkHostID=null,this._reolinkCameraUID=null,this._reolinkChannel=null,this._ptzEntities=null}async initialize(e){return await super.initialize(e),this._initializeChannel(),await this._initializeCapabilities(e.hass,e.entityRegistryManager),this}_initializeChannel(){const t=this._entity?.unique_id,i=t?String(t).match(/^(?<hostid>[A-Za-z0-9]+)_(?<channel_or_uid>[A-Za-z0-9]+)_/):null,a=i?.groups?.hostid??null,n=i?.groups?.channel_or_uid??null;if(null===a||null===n)throw new z(e("error.camera_initialization_reolink"),this.getConfig());const s=Number(n),r=!isNaN(s)&&s<=999,o=this._config.reolink.channel??(r?s:0),l=r?null:n;this._reolinkChannel=o,this._reolinkHostID=a,this._reolinkCameraUID=l}async _initializeCapabilities(e,i){const a=this.getConfig(),n=b(this.getConfig()),s=await this._getPTZEntities(e,i),r=s?this._entitiesToCapabilities(e,s):null,o=n||r?{...r,...n}:null;this._capabilities=new t({"favorite-events":!1,"favorite-recordings":!1,"remote-control-entity":!0,clips:!0,live:!0,menu:!0,recordings:!1,seek:!1,snapshots:!1,substream:!0,trigger:!0,...o&&{ptz:o}},{disable:a.capabilities?.disable,disableExcept:a.capabilities?.disable_except}),this._ptzEntities=s}_entitiesToCapabilities(e,t){const a={};for(const e of Object.keys(t))switch(e){case"left":case"right":case"up":case"down":a[e]=[i.Continuous];break;case"zoom_in":a.zoomIn=[i.Continuous];break;case"zoom_out":a.zoomOut=[i.Continuous]}const n=t?.presets?e.states[t.presets]:null;
/* istanbul ignore next: this path cannot be reached as ptzEntities will
        always have contents when this function is called  -- @preserve */
return Array.isArray(n?.attributes.options)&&(a.presets=n.attributes.options),Object.keys(a).length?a:null}async _getPTZEntities(e,t){
/* istanbul ignore next: this path cannot be reached as an exception is
           thrown in initialize() if this value is not found -- @preserve */
if(!this._reolinkHostID)return null;const i=this._getPTZEntityUniqueIDPrefix(),a=await t.getMatchingEntities(e,(e=>e.config_entry_id===this._entity?.config_entry_id&&!!e.unique_id&&String(e.unique_id).startsWith(i)&&!e.disabled_by)),n=a.filter((e=>e.entity_id.startsWith("button."))),s=a.filter((e=>e.unique_id===`${i}ptz_preset`&&e.entity_id.startsWith("select."))),r=["stop","left","right","up","down","zoom_in","zoom_out"],o={};for(const e of n)for(const t of r)e.unique_id&&String(e.unique_id).endsWith(t)&&(o[t]=e.entity_id);return 1===s.length&&(o.presets=s[0].entity_id),Object.keys(o).length?o:null}getChannel(){return this._reolinkChannel}_getPTZEntityUniqueIDPrefix(){return`${this._reolinkHostID}_${this._reolinkCameraUID??this._reolinkChannel}_`}getProxyConfig(){return{...super.getProxyConfig(),media:"auto"===this._config.proxy.media||this._config.proxy.media,ssl_verification:"auto"!==this._config.proxy.ssl_verification&&this._config.proxy.ssl_verification,ssl_ciphers:"auto"===this._config.proxy.ssl_ciphers?"intermediate":this._config.proxy.ssl_ciphers}}async executePTZAction(e,t,i){if(await super.executePTZAction(e,t,i))return!0;if(!this._ptzEntities)return!1;if("preset"===t){const t=this._ptzEntities.presets,n=i?.preset;return!(!n||!t)&&(await e.executeActions({actions:[a("select",t,n)]}),!0)}const n="start"===i?.phase?this._ptzEntities[t]:"stop"===i?.phase?this._ptzEntities.stop:null;return!!n&&(await e.executeActions({actions:[{action:"perform-action",perform_action:"button.press",target:{entity_id:n}}]}),!0)}}class x{static isReolinkEventQueryResults(e){return e.engine===r.Reolink&&e.type===d.Event}}class I extends f{constructor(){super(...arguments),this._cache=new s}getEngineType(){return r.Reolink}_reolinkFileMetadataGenerator(e,t,i){
/* istanbul ignore next: This situation cannot happen as the directory would
        be rejected by _reolinkDirectoryMetadataGenerator if there was no start date
        -- @preserve */
if(!i?._metadata?.startDate||t.media_class!==o)return null;const a=t.title.split(/ +/),n=D(a[0],"HH:mm:ss",i._metadata.startDate);if(!l(n))return null;const s=a.length>1?a[1].match(/(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)/):null,r=s?.groups?{hours:Number(s.groups.hours),minutes:Number(s.groups.minutes),seconds:Number(s.groups.seconds)}:null,u=a.length>2?a.splice(2).map((e=>e.toLowerCase())).sort():null;return{cameraID:e,startDate:n,endDate:r?c(n,r):n,...u&&{what:u}}}_reolinkDirectoryMetadataGenerator(e,t){const i=D(t.title,"yyyy/M/d",new Date);return l(i)?{cameraID:e,startDate:u(i),endDate:M(i)}:null}_reolinkCameraMetadataGenerator(e){const t=e.media_content_id.match(/^media-source:\/\/reolink\/CAM\|(?<configEntryID>.+)\|(?<channel>\d+)$/);return t?.groups?{configEntryID:t.groups.configEntryID,channel:Number(t.groups.channel)}:null}async createCamera(e,t){const i=new E(t,this,{eventCallback:this._eventCallback});return await i.initialize({entityRegistryManager:this._entityRegistryManager,hass:e,stateWatcher:this._stateWatcher})}async _getMatchingDirectories(e,t,i,a){const n=t.getConfig(),s=t.getEntity(),r=s?.config_entry_id;if(null===t.getChannel()||!r)return null;const o=await this._browseMediaManager.walkBrowseMedias(e,[{targets:["media-source://reolink"],metadataGenerator:(e,t)=>this._reolinkCameraMetadataGenerator(e),matcher:e=>e._metadata?.channel===t.getChannel()&&e._metadata?.configEntryID===r}],{...!1!==a?.useCache&&{cache:this._cache}});return o?.length?await this._browseMediaManager.walkBrowseMedias(e,[{targets:[`media-source://reolink/RES|${r}|${t.getChannel()}|`+("low"===n.reolink?.media_resolution?"sub":"main")],metadataGenerator:(e,i)=>this._reolinkDirectoryMetadataGenerator(t.getID(),e),matcher:e=>e.can_expand&&C(e,i?.start,i?.end),sorter:e=>h(e)}],{...!1!==a?.useCache&&{cache:this._cache}}):null}async getEvents(e,t,i,a){if(i.favorite||i.tags?.size||i.what?.size||i.where?.size||i.hasSnapshot)return null;const n=new Map,s=async s=>{const o={...i,cameraIDs:new Set([s])},l=a?.useCache??1?this._requestCache.get(o):null;if(l)return void n.set(o,l);const c=t.getCamera(s),u=c&&c instanceof E?await this._getMatchingDirectories(e,c,o,a):null,_=o.limit??k;let g=[];u?.length&&(g=await this._browseMediaManager.walkBrowseMedias(e,[{targets:u,concurrency:1,metadataGenerator:(e,t)=>this._reolinkFileMetadataGenerator(s,e,t),earlyExit:e=>e.length>=_,matcher:e=>!e.can_expand&&C(e,o.start,o.end),sorter:e=>h(e)}],{...!1!==a?.useCache&&{cache:this._cache}}));const m=p(g,(e=>e._metadata?.startDate),"desc").slice(0,_),y={type:d.Event,engine:r.Reolink,browseMedia:m};(a?.useCache??1)&&this._requestCache.set(o,{...y,cached:!0},y.expiry),n.set(o,y)};return await _(i.cameraIDs,(e=>s(e))),n}generateMediaFromEvents(e,t,i,a){return x.isReolinkEventQueryResults(a)?w(a.browseMedia):null}async getMediaMetadata(e,t,i,a){const n=new Map,s=a?.useCache??1?this._requestCache.get(i):null;if(s)return n.set(i,s),n;const o=new Set,l=async i=>{const n=t.getCamera(i);if(!(n&&n instanceof E))return;const s=await this._getMatchingDirectories(e,n,null,a);for(const e of s??[])
/* istanbul ignore next: This situation cannot happen as the directory
                will not match without metadata -- @preserve */
e._metadata&&o.add(m(e._metadata?.startDate))};await _(i.cameraIDs,(e=>l(e)));const u={type:d.MediaMetadata,engine:r.Reolink,metadata:{...o.size&&{days:o}},expiry:c(new Date,{seconds:g}),cached:!1};return(a?.useCache??1)&&this._requestCache.set(i,{...u,cached:!0},u.expiry),n.set(i,u),n}getCameraMetadata(e,t){return{...super.getCameraMetadata(e,t),engineIcon:"reolink"}}getCameraEndpoints(e,t){const i=e.reolink?.url?{endpoint:e.reolink.url}:null;return{...super.getCameraEndpoints(e,t),...i&&{ui:i}}}}export{I as ReolinkCameraManagerEngine,x as ReolinkQueryResultsClassifier};
