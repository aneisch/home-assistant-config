import{l as e,ec as t,eb as a,ea as n,eh as i,ed as s,el as r,ei as o,dW as c,d8 as l,em as u,ef as h,eg as d,ej as g,dg as _,di as m}from"./card-edf1c6f3.js";import{B as p,a as y,i as f,g as w}from"./within-dates-b24dba3f.js";import{C}from"./engine-86b0096c.js";import{g as k}from"./engine-generic-cff6e153.js";import{p as M}from"./parse-c8e1d099.js";import{e as b}from"./endOfDay-4ed8ce57.js";import"./media-c9012082.js";class D extends n{}class z extends p{constructor(){super(...arguments),this._channel=null,this._reolinkUniqueID=null,this._ptzButtons=null}async initialize(e){return await super.initialize(e),this._initializeChannel(),await this._initializeCapabilities(e.hass,e.entityRegistryManager),this}_initializeChannel(){const t=this._entity?.unique_id,a=t?String(t).match(/(?<uniqueid>.*)_(?<channel>\d+)/):null,n=a&&a.groups?.channel?Number(a.groups.channel):null,i=a?.groups?.uniqueid??null;if(null===n||null===i)throw new D(e("error.camera_initialization_reolink"),this.getConfig());this._channel=n,this._reolinkUniqueID=i}async _initializeCapabilities(e,n){const i=this.getConfig(),s=await this._getPTZButtons(e,n),r=k(this.getConfig()),o={};for(const e of Object.keys(s??{}))switch(e){case"left":case"right":case"up":case"down":o[e]=[t.Continuous];break;case"zoom_in":o.zoomIn=[t.Continuous];break;case"zoom_out":o.zoomOut=[t.Continuous]}const c=r||Object.keys(o).length?{...o,...r}:null;this._capabilities=new a({"favorite-events":!1,"favorite-recordings":!1,"remote-control-entity":!0,clips:!0,live:!0,menu:!0,recordings:!1,seek:!1,snapshots:!1,substream:!0,trigger:!0,...c&&{ptz:c}},{disable:i.capabilities?.disable,disableExcept:i.capabilities?.disable_except}),this._ptzButtons=s}async _getPTZButtons(e,t){
/* istanbul ignore next: this path cannot be reached as an exception is
           thrown in initialize() if this value is not found -- @preserve */
if(!this._reolinkUniqueID)return null;const a=`${this._reolinkUniqueID}_${this._channel}_`,n=await t.getMatchingEntities(e,(e=>e.config_entry_id===this._entity?.config_entry_id&&!!e.unique_id&&String(e.unique_id).startsWith(a)&&!e.disabled_by&&e.entity_id.startsWith("button."))),i=["stop","left","right","up","down","zoom_in","zoom_out"],s={};for(const e of n)for(const t of i)e.unique_id&&String(e.unique_id).endsWith(t)&&(s[t]=e.entity_id);return Object.keys(s).length?s:null}getChannel(){return this._channel}getProxyConfig(){return{...super.getProxyConfig(),media:"auto"===this._config.proxy.media||this._config.proxy.media,ssl_verification:"auto"!==this._config.proxy.ssl_verification&&this._config.proxy.ssl_verification,ssl_ciphers:"auto"===this._config.proxy.ssl_ciphers?"intermediate":this._config.proxy.ssl_ciphers}}async executePTZAction(e,t,a){if(await super.executePTZAction(e,t,a))return!0;const n="start"===a?.phase?this._ptzButtons?.[t]:"stop"===a?.phase?this._ptzButtons?.stop:null;return!!n&&(await e.executeActions({actions:[{action:"perform-action",perform_action:"button.press",target:{entity_id:n}}]}),!0)}}class x{static isReolinkEventQueryResults(e){return e.engine===s.Reolink&&e.type===d.Event}}class v extends y{constructor(){super(...arguments),this._cache=new i}getEngineType(){return s.Reolink}_reolinkFileMetadataGenerator(e,t,a){
/* istanbul ignore next: This situation cannot happen as the directory would
        be rejected by _reolinkDirectoryMetadataGenerator if there was no start date
        -- @preserve */
if(!a?._metadata?.startDate||t.media_class!==r)return null;const n=t.title.split(/ +/),i=M(n[0],"HH:mm:ss",a._metadata.startDate);if(!o(i))return null;const s=n.length>1?n[1].match(/(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)/):null,l=s?.groups?{hours:Number(s.groups.hours),minutes:Number(s.groups.minutes),seconds:Number(s.groups.seconds)}:null,u=n.length>2?n.splice(2).map((e=>e.toLowerCase())).sort():null;return{cameraID:e,startDate:i,endDate:l?c(i,l):i,...u&&{what:u}}}_reolinkDirectoryMetadataGenerator(e,t){const a=M(t.title,"yyyy/M/d",new Date);return o(a)?{cameraID:e,startDate:l(a),endDate:b(a)}:null}_reolinkCameraMetadataGenerator(e){const t=e.media_content_id.match(/^media-source:\/\/reolink\/CAM\|(?<configEntryID>.+)\|(?<channel>\d+)$/);return t?.groups?{configEntryID:t.groups.configEntryID,channel:Number(t.groups.channel)}:null}async createCamera(e,t){const a=new z(t,this,{eventCallback:this._eventCallback});return await a.initialize({entityRegistryManager:this._entityRegistryManager,hass:e,stateWatcher:this._stateWatcher})}async _getMatchingDirectories(e,t,a,n){const i=t.getConfig(),s=t.getEntity(),r=s?.config_entry_id;if(null===t.getChannel()||!r)return null;const o=await this._browseMediaManager.walkBrowseMedias(e,[{targets:["media-source://reolink"],metadataGenerator:(e,t)=>this._reolinkCameraMetadataGenerator(e),matcher:e=>e._metadata?.channel===t.getChannel()&&e._metadata?.configEntryID===r}],{...!1!==n?.useCache&&{cache:this._cache}});return o?.length?await this._browseMediaManager.walkBrowseMedias(e,[{targets:[`media-source://reolink/RES|${r}|${t.getChannel()}|`+("low"===i.reolink?.media_resolution?"sub":"main")],metadataGenerator:(e,a)=>this._reolinkDirectoryMetadataGenerator(t.getID(),e),matcher:e=>e.can_expand&&f(e,a?.start,a?.end),sorter:e=>u(e)}],{...!1!==n?.useCache&&{cache:this._cache}}):null}async getEvents(e,t,a,n){if(a.favorite||a.tags?.size||a.what?.size||a.where?.size||a.hasSnapshot)return null;const i=new Map,r=async r=>{const o={...a,cameraIDs:new Set([r])},c=n?.useCache??1?this._requestCache.get(o):null;if(c)return void i.set(o,c);const l=t.getCamera(r),h=l&&l instanceof z?await this._getMatchingDirectories(e,l,o,n):null,g=o.limit??C;let m=[];h?.length&&(m=await this._browseMediaManager.walkBrowseMedias(e,[{targets:h,concurrency:1,metadataGenerator:(e,t)=>this._reolinkFileMetadataGenerator(r,e,t),earlyExit:e=>e.length>=g,matcher:e=>!e.can_expand&&f(e,o.start,o.end),sorter:e=>u(e)}],{...!1!==n?.useCache&&{cache:this._cache}}));const p=_(m,(e=>e._metadata?.startDate),"desc").slice(0,g),y={type:d.Event,engine:s.Reolink,browseMedia:p};(n?.useCache??1)&&this._requestCache.set(o,{...y,cached:!0},y.expiry),i.set(o,y)};return await h(a.cameraIDs,(e=>r(e))),i}generateMediaFromEvents(e,t,a,n){return x.isReolinkEventQueryResults(n)?w(n.browseMedia):null}async getMediaMetadata(e,t,a,n){const i=new Map,r=n?.useCache??1?this._requestCache.get(a):null;if(r)return i.set(a,r),i;const o=new Set,l=async a=>{const i=t.getCamera(a);if(!(i&&i instanceof z))return;const s=await this._getMatchingDirectories(e,i,null,n);for(const e of s??[])
/* istanbul ignore next: This situation cannot happen as the directory
                will not match without metadata -- @preserve */
e._metadata&&o.add(m(e._metadata?.startDate))};await h(a.cameraIDs,(e=>l(e)));const u={type:d.MediaMetadata,engine:s.Reolink,metadata:{...o.size&&{days:o}},expiry:c(new Date,{seconds:g}),cached:!1};return(n?.useCache??1)&&this._requestCache.set(a,{...u,cached:!0},u.expiry),i.set(a,u),i}getCameraMetadata(e,t){return{...super.getCameraMetadata(e,t),engineIcon:"reolink"}}getCameraEndpoints(e,t){const a=e.reolink?.url?{endpoint:e.reolink.url}:null;return{...super.getCameraEndpoints(e,t),...a&&{ui:a}}}}export{v as ReolinkCameraManagerEngine,x as ReolinkQueryResultsClassifier};
