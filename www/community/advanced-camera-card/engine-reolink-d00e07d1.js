import{dW as e,l as t,el as i,em as a,ez as n,ek as s,et as r,ep as o,ey as l,dV as c,eu as u,e4 as h,dR as _,er as d,ev as g,es as p,ew as m,dY as y}from"./card-eed141c1.js";import{B as f,a as C,i as k}from"./engine-browse-media-c3b00282.js";import{C as w}from"./engine-86b0096c.js";import{g as b}from"./engine-generic-745f3a87.js";import{e as D}from"./endOfDay-719c9c15.js";const z=t=>e(t,(e=>e._metadata?.startDate),"desc");class M extends s{}class E extends f{constructor(){super(...arguments),this._reolinkHostID=null,this._reolinkCameraUID=null,this._reolinkChannel=null,this._ptzEntities=null}async initialize(e){return await super.initialize(e),this._initializeChannel(),await this._initializeCapabilities(e.hass,e.entityRegistryManager),this}_initializeChannel(){const e=this._entity?.unique_id,i=e?String(e).match(/^(?<hostid>[A-Za-z0-9]+)_(?<channel_or_uid>[A-Za-z0-9]+)_/):null,a=i?.groups?.hostid??null,n=i?.groups?.channel_or_uid??null;if(null===a||null===n)throw new M(t("error.camera_initialization_reolink"),this.getConfig());const s=Number(n),r=!isNaN(s)&&s<=999,o=this._config.reolink.channel??(r?s:0),l=r?null:n;this._reolinkChannel=o,this._reolinkHostID=a,this._reolinkCameraUID=l}async _initializeCapabilities(e,t){const a=this.getConfig(),n=b(this.getConfig()),s=await this._getPTZEntities(e,t),r=s?this._entitiesToCapabilities(e,s):null,o=n||r?{...r,...n}:null;this._capabilities=new i({"favorite-events":!1,"favorite-recordings":!1,"remote-control-entity":!0,clips:!0,live:!0,menu:!0,recordings:!1,seek:!1,snapshots:!1,substream:!0,trigger:!0,...o&&{ptz:o}},{disable:a.capabilities?.disable,disableExcept:a.capabilities?.disable_except}),this._ptzEntities=s}_entitiesToCapabilities(e,t){const i={};for(const e of Object.keys(t))switch(e){case"left":case"right":case"up":case"down":i[e]=[a.Continuous];break;case"zoom_in":i.zoomIn=[a.Continuous];break;case"zoom_out":i.zoomOut=[a.Continuous]}const n=t?.presets?e.states[t.presets]:null;
/* istanbul ignore next: this path cannot be reached as ptzEntities will
        always have contents when this function is called  -- @preserve */
return Array.isArray(n?.attributes.options)&&(i.presets=n.attributes.options),Object.keys(i).length?i:null}async _getPTZEntities(e,t){
/* istanbul ignore next: this path cannot be reached as an exception is
           thrown in initialize() if this value is not found -- @preserve */
if(!this._reolinkHostID)return null;const i=this._getPTZEntityUniqueIDPrefix(),a=await t.getMatchingEntities(e,(e=>e.config_entry_id===this._entity?.config_entry_id&&!!e.unique_id&&String(e.unique_id).startsWith(i)&&!e.disabled_by)),n=a.filter((e=>e.entity_id.startsWith("button."))),s=a.filter((e=>e.unique_id===`${i}ptz_preset`&&e.entity_id.startsWith("select."))),r=["stop","left","right","up","down","zoom_in","zoom_out"],o={};for(const e of n)for(const t of r)e.unique_id&&String(e.unique_id).endsWith(t)&&(o[t]=e.entity_id);return 1===s.length&&(o.presets=s[0].entity_id),Object.keys(o).length?o:null}getChannel(){return this._reolinkChannel}_getPTZEntityUniqueIDPrefix(){return`${this._reolinkHostID}_${this._reolinkCameraUID??this._reolinkChannel}_`}getProxyConfig(){return{...super.getProxyConfig(),media:"auto"===this._config.proxy.media||this._config.proxy.media,ssl_verification:"auto"!==this._config.proxy.ssl_verification&&this._config.proxy.ssl_verification,ssl_ciphers:"auto"===this._config.proxy.ssl_ciphers?"intermediate":this._config.proxy.ssl_ciphers}}async executePTZAction(e,t,i){if(await super.executePTZAction(e,t,i))return!0;if(!this._ptzEntities)return!1;if("preset"===t){const t=this._ptzEntities.presets,a=i?.preset;return!(!a||!t)&&(await e.executeActions({actions:[n("select",t,a)]}),!0)}const a="start"===i?.phase?this._ptzEntities[t]:"stop"===i?.phase?this._ptzEntities.stop:null;return!!a&&(await e.executeActions({actions:[{action:"perform-action",perform_action:"button.press",target:{entity_id:a}}]}),!0)}}class x{static isReolinkEventQueryResults(e){return e.engine===o.Reolink&&e.type===p.Event}}class I extends C{constructor(){super(...arguments),this._camerasCache=new r,this._cache=new r}getEngineType(){return o.Reolink}_reolinkFileMetadataGenerator(e,t,i){
/* istanbul ignore next: This situation cannot happen as the directory would
        be rejected by _reolinkDirectoryMetadataGenerator if there was no start date
        -- @preserve */
if(!i?._metadata?.startDate||t.media_class!==l)return null;const a=t.title.split(/ +/),n=c(a[0],"HH:mm:ss",i._metadata.startDate);if(!u(n))return null;const s=a.length>1?a[1].match(/(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)/):null,r=s?.groups?{hours:Number(s.groups.hours),minutes:Number(s.groups.minutes),seconds:Number(s.groups.seconds)}:null,o=a.length>2?a.splice(2).map((e=>e.toLowerCase())).sort():null;return{cameraID:e,startDate:n,endDate:r?h(n,r):n,...o&&{what:o}}}_reolinkDirectoryMetadataGenerator(e,t){const i=c(t.title,"yyyy/M/d",new Date);return u(i)?{cameraID:e,startDate:_(i),endDate:D(i)}:null}_reolinkCameraMetadataGenerator(e){const t=e.media_content_id.match(/^media-source:\/\/reolink\/CAM\|(?<configEntryID>.+)\|(?<channel>\d+)$/);return t?.groups?{configEntryID:t.groups.configEntryID,channel:Number(t.groups.channel)}:null}async createCamera(e,t){const i=new E(t,this,{eventCallback:this._eventCallback});return await i.initialize({entityRegistryManager:this._entityRegistryManager,hass:e,stateWatcher:this._stateWatcher})}async _getMatchingDirectories(e,t,i,a){const n=t.getConfig(),s=t.getEntity(),r=s?.config_entry_id;if(null===t.getChannel()||!r)return null;const o=await this._browseMediaWalker.walk(e,[{targets:["media-source://reolink"],metadataGenerator:(e,t)=>this._reolinkCameraMetadataGenerator(e),matcher:e=>e._metadata?.channel===t.getChannel()&&e._metadata?.configEntryID===r}],{...!1!==a?.useCache&&{cache:this._camerasCache}});return o?.length?await this._browseMediaWalker.walk(e,[{targets:[`media-source://reolink/RES|${r}|${t.getChannel()}|`+("low"===n.reolink?.media_resolution?"sub":"main")],metadataGenerator:(e,i)=>this._reolinkDirectoryMetadataGenerator(t.getID(),e),matcher:e=>e.can_expand&&k(e,i?.start,i?.end),sorter:e=>z(e)}],{...!1!==a?.useCache&&{cache:this._cache}}):null}async getEvents(t,i,a,n){if(a.favorite||a.tags?.size||a.what?.size||a.where?.size||a.hasSnapshot)return null;const s=new Map,r=async r=>{const l={...a,cameraIDs:new Set([r])},c=n?.useCache??1?this._requestCache.get(l):null;if(c)return void s.set(l,c);const u=i.getCamera(r),h=u&&u instanceof E?await this._getMatchingDirectories(t,u,l,n):null,_=l.limit??w;let d=[];h?.length&&(d=await this._browseMediaWalker.walk(t,[{targets:h,concurrency:1,metadataGenerator:(e,t)=>this._reolinkFileMetadataGenerator(r,e,t),earlyExit:e=>e.length>=_,matcher:e=>!e.can_expand&&k(e,l.start,l.end),sorter:e=>z(e)}],{...!1!==n?.useCache&&{cache:this._cache}}));const g=e(d,(e=>e._metadata?.startDate),"desc").slice(0,_),m={type:p.Event,engine:o.Reolink,browseMedia:g};(n?.useCache??1)&&this._requestCache.set(l,{...m,cached:!0},m.expiry),s.set(l,m)};return await d(a.cameraIDs,(e=>r(e))),s}generateMediaFromEvents(e,t,i,a){return x.isReolinkEventQueryResults(a)?g(a.browseMedia):null}async getMediaMetadata(e,t,i,a){const n=new Map,s=a?.useCache??1?this._requestCache.get(i):null;if(s)return n.set(i,s),n;const r=new Set,l=async i=>{const n=t.getCamera(i);if(!(n&&n instanceof E))return;const s=await this._getMatchingDirectories(e,n,null,a);for(const e of s??[])
/* istanbul ignore next: This situation cannot happen as the directory
                will not match without metadata -- @preserve */
e._metadata?.startDate&&r.add(y(e._metadata.startDate))};await d(i.cameraIDs,(e=>l(e)));const c={type:p.MediaMetadata,engine:o.Reolink,metadata:{...r.size&&{days:r}},expiry:h(new Date,{seconds:m}),cached:!1};return(a?.useCache??1)&&this._requestCache.set(i,{...c,cached:!0},c.expiry),n.set(i,c),n}getCameraMetadata(e,t){return{...super.getCameraMetadata(e,t),engineIcon:"reolink"}}getCameraEndpoints(e,t){const i=e.reolink?.url?{endpoint:e.reolink.url}:null;return{...super.getCameraEndpoints(e,t),...i&&{ui:i}}}}export{I as ReolinkCameraManagerEngine,x as ReolinkQueryResultsClassifier};
