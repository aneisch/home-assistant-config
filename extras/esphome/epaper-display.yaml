# https://wiki.seeedstudio.com/xiao_075inch_epaper_panel/#hardware-overview
esphome:
  name: epaper-display
  friendly_name: epaper_display

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

<<: !include common.yaml

# Display info via SPI
spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: first_update_done
    type: bool
    restore_value: no
    initial_value: "false"

wifi:
  ssid: "SSID"
  password: !secret wifi_password
  on_connect:
    then:
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;

# When device in deep sleep mode, you can't upload a new program derectly.
# First, make sure that device is turned on, and then press the Boot button on the back of the board.
# Click one time Reset button and release Boot button.
# After that, turn off the battery switch and unplug the power cable.
# Last, replug the cable and upload a new program.
deep_sleep:
  id: deep_sleep_1
  run_duration: 1min # Device wake up and run 60s (enough to pull data and update)
  sleep_duration: 30min  # deep sleep for 30min

interval:
  # Deep sleep
  - interval: 59s  # run this command before the end of run_duration
    then:
      - logger.log: "Entering deep sleep now momentarily..."

  # Sleep after 11:55PM until 07:30AM
  - interval: 10s
    then:
      - if:
          condition:
            lambda: |-
              auto now = id(homeassistant_time).now();
              ESP_LOGD("main", "Evaluating");
              return now.is_valid() && now.hour == 00;
          then:
            - logger.log: "After 12:00AM — entering deep sleep until 08:00."
            - deep_sleep.enter:
                id: deep_sleep_1
                until: "08:00:00"
                time_id: homeassistant_time

  # Condition: wifi connected && data retrieved && first time
  - interval: 10s  # Check every second
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - lambda: "return !id(first_update_done);"
          then:
            - delay: 5s
            - lambda: |-
                ESP_LOGD("Display", "Triggered Display Update...");
            - component.update: my_display
            - lambda: "id(first_update_done) = true;"

# Connect to Home Assistant to get time
time:
  - platform: homeassistant
    id: homeassistant_time

text_sensor:
  - platform: homeassistant
    entity_id: weather.kcll_daynight
    id: myWeather
  - platform: homeassistant
    entity_id: sensor.433_weather_temperature
    id: temp
  # - platform: homeassistant
  #   entity_id: weather.kcll_daynight
  #   id: temp
  #   attribute: "temperature"
  - platform: homeassistant
    entity_id: sensor.433_weather_humidity
    id: humi
  # - platform: homeassistant
  #   entity_id: weather.kcll_daynight
  #   id: humi
  #   attribute: "humidity"
  - platform: homeassistant
    entity_id: weather.kcll_daynight
    id: press
    attribute: "pressure"
  - platform: homeassistant
    entity_id: weather.kcll_daynight
    id: wind
    attribute: "wind_speed"
  - platform: homeassistant
    entity_id: sensor.solark_sol_ark_day_pv_energy
    id: production
  - platform: homeassistant
    entity_id: sensor.solark_sol_ark_battery_soc
    id: battery
  - platform: homeassistant
    entity_id: sensor.solark_sol_ark_day_grid_export
    id: grid_export
  - platform: homeassistant
    entity_id: sensor.solark_sol_ark_day_grid_import
    id: grid_import
  - platform: homeassistant
    entity_id: sensor.forecast_twice_daily
    id: forecast
    attribute: "detailed_description"
  - platform: homeassistant
    entity_id: input_select.epaper_toggle
    id: toggle

font:
  - file: "fonts/Montserrat-Black.ttf"
    id: web_font
    size: 20
  - file: "fonts/Montserrat-Black.ttf"
    id: update_font
    size: 12
  - file: "fonts/Montserrat-Black.ttf"
    id: data_font
    size: 30
  - file: "fonts/Montserrat-Black.ttf"
    id: title_font
    size: 40
  - file: "fonts/Montserrat-Black.ttf"
    id: sensor_font
    size: 22
  - file: "gfonts://Inter@700" #
    id: font1
    size: 24

  - file: 'fonts/materialdesignicons-webfont.ttf' # Directory to save ttf file
    id: font_mdi_large
    size: 200
    glyphs: &mdi-weather-glyphs # https://pictogrammers.com/library/mdi/
      - "\U000F050F" # Thermometer
      - "\U000F058E" # Humidity
      - "\U000F059D" # Wind speed
      - "\U000F0D60" # Atmospheric pressure
      - "\U000F0590" # Cloudy weather
      - "\U000F0596" # Rainy weather
      - "\U000F0598" # Snowy weather
      - "\U000F0599" # Sunny weather
      - "\U000F0D9B" # Solar
      - "\U000F008B" # Battery
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_weather # Copy the above icon and change the size to 40
    size: 200
    glyphs: *mdi-weather-glyphs
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: img_font_sensor # Copy the above icon and change the size to 40
    size: 70
    glyphs: *mdi-weather-glyphs

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: GPIO4
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: never
    lambda: |-
      // 1. GLOBAL INVERSION - Start by filling the entire screen BLACK
      it.fill(COLOR_ON);

      ESP_LOGD("Display", "Updating Display @ Component...");
      
      if(id(wifi_status) == 0){
        // it.print(230, 300, id(data_font), COLOR_OFF, "WI-FI CONNECTING");
      }
      else {
        auto time_now = id(homeassistant_time).now();
        int w = 180, h = 120, r = 10, thickness = 4;

        if(id(toggle).state == "weather" || id(toggle).state == "solar") {
          // --- SHARED HEADER SECTION (Weather Icon & Date) ---
          std::string weather_string = id(myWeather).state.c_str();
          const char* weather_icon = "\U000F0590"; // default cloudy
          if(weather_string == "rainy" || weather_string == "lightning" || weather_string == "pouring") weather_icon = "\U000F0596";
          else if(weather_string == "snowy") weather_icon = "\U000F0598";
          else if(weather_string == "sunny" || weather_string == "windy") weather_icon = "\U000F0599";
          
          it.printf(120, 85, id(font_weather), COLOR_OFF, TextAlign::CENTER, weather_icon);

          const char* months[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
          const char* days[] = {"Saturday", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday"};
          
          it.printf(250, 110, id(title_font), COLOR_OFF, "%s %d", months[time_now.month - 1], time_now.day_of_month);
          it.printf(250, 70, id(title_font), COLOR_OFF, "%s", days[time_now.day_of_week]);

          // --- COMMON SENSOR BOXES (Temp, Humi, Press, Wind) ---
          // This lambda draws the box inverted (White border, Black inside)
          auto draw_sensor_box = [&](int x, int y, const char* title, const char* icon, std::string value, const char* unit) {
            it.filled_rectangle(x + r, y, w - 2 * r, thickness, COLOR_OFF); 
            it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness, COLOR_OFF);
            it.filled_rectangle(x, y + r, thickness, h - 2 * r, COLOR_OFF);
            it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r, COLOR_OFF);
            it.filled_circle(x + r, y + r, r, COLOR_OFF);
            it.filled_circle(x + w - r, y + r, r, COLOR_OFF);
            it.filled_circle(x + r, y + h - r, r, COLOR_OFF);
            it.filled_circle(x + w - r, y + h - r, r, COLOR_OFF);
            it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_ON);

            it.printf(x+10, y+10, id(sensor_font), COLOR_OFF, title);
            it.printf(x+45, y+75, id(img_font_sensor), COLOR_OFF, TextAlign::CENTER, icon);
            
            if (unit == "inHg" || unit == "mph") {
                it.printf(x+85, y+50, id(data_font), COLOR_OFF, "%s", value.c_str());
                it.printf(x+85, y+78, id(sensor_font), COLOR_OFF, unit);
            } else {
                it.printf(x+75, y+65, id(data_font), COLOR_OFF, "%s%s", value.c_str(), unit);
            }
          };

          // Temp
          std::string t_val = id(temp).state.c_str();
          if (t_val.find(".") != std::string::npos) t_val = t_val.substr(0, t_val.find("."));
          draw_sensor_box(20, 180, "Temperature", "\U000F050F", t_val, "°F");

          // Humidity
          std::string h_val = id(humi).state.c_str();
          if (h_val.find(".") != std::string::npos) h_val = h_val.substr(0, h_val.find("."));
          draw_sensor_box(220, 180, "Humidity", "\U000F058E", h_val, "%");

          // Pressure
          draw_sensor_box(20, 320, "Air Pressure", "\U000F0D60", id(press).state.c_str(), "inHg");

          // Wind
          draw_sensor_box(220, 320, "Wind Speed", "\U000F059D", id(wind).state.c_str(), "mph");
        }

        if(id(toggle).state == "weather"){
          // --- WEATHER FORECAST TEXT WRAP ---
          std::string input = id(forecast).state.c_str();
          std::string output;
          size_t max_len = 25; size_t line_len = 0; size_t i = 0;
          while(i < input.length()) {
            size_t next_space = input.find(' ', i);
            if(next_space == std::string::npos) next_space = input.length();
            size_t word_len = next_space - i;
            if(line_len + word_len > max_len) { output += '\n'; line_len = 0; }
            output += input.substr(i, word_len);
            line_len += word_len;
            if(next_space < input.length()) { output += ' '; line_len += 1; }
            i = next_space + 1;
          }

          size_t y_start = 170; size_t x_start = 430; int line_height = 22;
          size_t pos = 0; size_t next_pos; int line_num = 0;
          while((next_pos = output.find('\n', pos)) != std::string::npos) {
            it.print(x_start, y_start + line_num * line_height, id(sensor_font), COLOR_OFF, output.substr(pos, next_pos - pos).c_str());
            pos = next_pos + 1; line_num++;
          }
          if(pos < output.length()) it.print(x_start, y_start + line_num * line_height, id(sensor_font), COLOR_OFF, output.substr(pos).c_str());
        }

        if(id(toggle).state == "solar"){
          // --- SOLAR SENSOR BOXES ---
          auto draw_solar_box = [&](int x, int y, const char* title, const char* icon, float val, const char* unit) {
            it.filled_rectangle(x + r, y, w - 2 * r, thickness, COLOR_OFF); 
            it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness, COLOR_OFF);
            it.filled_rectangle(x, y + r, thickness, h - 2 * r, COLOR_OFF);
            it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r, COLOR_OFF);
            it.filled_circle(x + r, y + r, r, COLOR_OFF);
            it.filled_circle(x + w - r, y + r, r, COLOR_OFF);
            it.filled_circle(x + r, y + h - r, r, COLOR_OFF);
            it.filled_circle(x + w - r, y + h - r, r, COLOR_OFF);
            it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_ON);
            
            it.printf(x+10, y+10, id(sensor_font), COLOR_OFF, title);
            it.printf(x+45, y+75, id(img_font_sensor), COLOR_OFF, TextAlign::CENTER, icon);
            it.printf(x+85, y+50, id(data_font), COLOR_OFF, (unit == "%%" ? "%.0f" : "%.1f"), val);
            it.printf(x+85, y+78, id(sensor_font), COLOR_OFF, unit);
          };

          draw_solar_box(520, 35,  "Production", "\U000F0D9B", atof(id(production).state.c_str()), "kWh");
          draw_solar_box(520, 180, "Export",     "\U000F0D9B", atof(id(grid_export).state.c_str()), "kWh");
          draw_solar_box(520, 320, "Battery",    "\U000F008B", atof(id(battery).state.c_str()), "%%");
        }

        // Draw update time at the bottom
        it.strftime(5, 462, id(update_font), COLOR_OFF, "Updated %b %d, %Y %I:%M %p", time_now);
      }

# Or show image
# http_request:
#   verify_ssl: false
#   timeout: 10s
#   watchdog_timeout: 15s

# online_image:
#   - id: dashboard_image
#     format: PNG
#     type: BINARY
#     buffer_size: 30000
#     url: http://192.168.1.191:10000/todo?viewport=800x480&eink=2&invert #change this link to your screenshot link
#     update_interval: 30s
#     on_download_finished:
#       - delay: 0ms
#       - component.update: main_display

# display:
#   - platform: waveshare_epaper
#     id: main_display
#     cs_pin: GPIO3
#     dc_pin: GPIO5
#     busy_pin: GPIO4
#     reset_pin: GPIO2
#     model: 7.50inv2
#     update_interval: never
#     lambda: |-
#       it.image(0, 0, id(dashboard_image));